import { chromium, Browser, Page } from 'playwright';
import { ComprehensiveProfile, ApplicationSessionRecord } from '@shared/schema';
import { storage } from '../storage';
import { EmailService } from './email-service';
import { WhatsAppService } from './whatsapp-service';
import { OpenAIService } from './openai-service';
import { AutoLoginService, LoginCredentials } from './auto-login-service';
import { ScreenshotService } from './screenshot-service';
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';
import path from 'path';
import { promises as fs } from 'fs';

export interface EnhancedJobApplicationRequest {
  jobUrl: string;
  profile: ComprehensiveProfile;
  resumeFile?: Buffer;
  coverLetterFile?: Buffer;
}

export class EnhancedAutoApplyWorkflowService {
  private browser: Browser | null = null;
  private emailService: EmailService;
  private whatsappService: WhatsAppService;
  private openaiService: OpenAIService;
  private autoLoginService: AutoLoginService;
  private screenshotService: ScreenshotService;

  constructor() {
    this.emailService = new EmailService();
    this.whatsappService = new WhatsAppService();
    this.openaiService = new OpenAIService();
    this.autoLoginService = new AutoLoginService();
    this.screenshotService = new ScreenshotService();
  }

  async startEnhancedAutoApplyProcess(request: EnhancedJobApplicationRequest): Promise<{
    success: boolean;
    sessionId?: string;
    message: string;
  }> {
    let sessionId = '';
    let page: Page | null = null;

    try {
      // Create user if doesn't exist
      let user = await storage.getUserByEmail(request.profile.email);
      if (!user) {
        user = await storage.createUser({
          name: request.profile.name,
          email: request.profile.email,
          phone: request.profile.phone,
          resumeFileName: request.profile.resumeFileName,
          coverLetterFileName: request.profile.coverLetterFileName,
        });
      }

      // Create application session
      sessionId = uuidv4();
      const approvalToken = uuidv4().replace(/-/g, '');
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours

      // Encrypt login credentials
      let encryptedCredentials = null;
      if (request.profile.loginEmail && request.profile.loginPassword) {
        encryptedCredentials = this.encryptCredentials({
          email: request.profile.loginEmail,
          password: request.profile.loginPassword,
          method: request.profile.preferredLoginMethod || 'email'
        });
      }

      const session = await storage.createApplicationSession({
        id: sessionId,
        userId: user.id,
        jobUrl: request.jobUrl,
        platform: this.detectPlatform(request.jobUrl),
        status: 'pending_review',
        profileData: request.profile,
        loginCredentials: encryptedCredentials,
        approvalToken,
        expiresAt,
        reviewEmailSent: false,
        whatsappReviewSent: false,
      });

      // Launch browser and start automation
      this.browser = await this.launchBrowser();
      page = await this.browser.newPage();

      // Step 1: Navigate to job page and extract details
      await page.goto(request.jobUrl, { waitUntil: 'networkidle' });
      const jobDetails = await this.extractJobDetails(page, request.jobUrl);

      // Update session with job details
      await storage.updateApplicationSession(sessionId, {
        jobTitle: jobDetails.jobTitle,
        company: jobDetails.companyName,
      });

      // Step 2: Auto-login if credentials provided
      let loginSuccess = false;
      if (encryptedCredentials) {
        const credentials = this.decryptCredentials(encryptedCredentials);
        loginSuccess = await this.autoLoginService.performAutoLogin(page, credentials, request.jobUrl);
        console.log(loginSuccess ? '‚úÖ Auto-login successful' : '‚ùå Auto-login failed');
      }

      // Step 3: Generate AI cover letter if enabled
      let generatedCoverLetter = '';
      if (request.profile.enableAICoverLetter && jobDetails.jobDescription) {
        try {
          generatedCoverLetter = await this.openaiService.generateCoverLetter(
            jobDetails.jobDescription,
            jobDetails.jobTitle,
            jobDetails.companyName,
            request.profile,
            request.profile.coverLetterTemplate
          );
          
          await storage.updateApplicationSession(sessionId, {
            autoGeneratedCoverLetter: generatedCoverLetter,
          });
        } catch (error) {
          console.log('AI cover letter generation failed:', error);
        }
      }

      // Step 4: Navigate to application form
      const applicationFormUrl = await this.findApplicationForm(page);
      if (applicationFormUrl && applicationFormUrl !== page.url()) {
        await page.goto(applicationFormUrl, { waitUntil: 'networkidle' });
      }

      // Step 5: Detect CAPTCHA
      const hasCaptcha = await this.autoLoginService.detectCaptcha(page);
      if (hasCaptcha) {
        console.log('ü§ñ CAPTCHA detected - manual intervention may be needed');
      }

      // Step 6: Analyze and fill form
      const formData = await this.analyzeAndFillForm(
        page, 
        request.profile, 
        request.resumeFile, 
        request.coverLetterFile || (generatedCoverLetter ? Buffer.from(generatedCoverLetter) : undefined),
        sessionId
      );

      // Update session with filled form data
      await storage.updateApplicationSession(sessionId, {
        filledFormData: formData,
      });

      // Step 7: Take form preview screenshot
      const previewScreenshot = await this.screenshotService.captureFormPreview(page, sessionId);

      // Step 8: Send review notifications
      const emailSent = await this.emailService.sendReviewEmail(
        { ...session, filledFormData: formData } as ApplicationSessionRecord,
        formData
      );

      let whatsappSent = false;
      if (request.profile.enableWhatsappNotifications && request.profile.whatsappNumber) {
        const approvalUrl = `${process.env.BASE_URL || 'http://localhost:5000'}/api/approve/${approvalToken}`;
        const rejectUrl = `${process.env.BASE_URL || 'http://localhost:5000'}/api/reject/${approvalToken}`;
        
        whatsappSent = await this.whatsappService.sendJobApplicationReview(
          request.profile.whatsappNumber,
          jobDetails.jobTitle,
          jobDetails.companyName,
          approvalUrl,
          rejectUrl
        );
      }

      // Update notification status
      await storage.updateApplicationSession(sessionId, {
        reviewEmailSent: emailSent,
        whatsappReviewSent: whatsappSent,
      });

      // Step 9: Start 60-second auto-submit timer
      this.startAutoSubmitTimer(sessionId, page);

      // Log the application attempt
      await storage.createApplicationLog({
        sessionId,
        userId: user.id,
        jobTitle: jobDetails.jobTitle,
        companyName: jobDetails.companyName,
        jobUrl: request.jobUrl,
        result: 'pending',
        notes: `Form filled, review notifications sent. CAPTCHA: ${hasCaptcha ? 'detected' : 'none'}`,
      });

      return {
        success: true,
        sessionId,
        message: `üöÄ Enhanced auto-apply workflow started! Job: ${jobDetails.jobTitle} at ${jobDetails.companyName}. Review email sent${whatsappSent ? ' and WhatsApp notification sent' : ''}. Please approve within 60 seconds.`
      };

    } catch (error) {
      console.error('Enhanced auto-apply workflow error:', error);
      
      // Take error screenshot if page exists
      if (page && sessionId) {
        await this.screenshotService.captureErrorScreenshot(page, sessionId, (error as Error).message);
      }

      // Log failed attempt
      if (sessionId) {
        await storage.updateApplicationSession(sessionId, {
          status: 'failed',
          errorMessage: (error as Error).message,
        });

        await storage.createApplicationLog({
          sessionId,
          userId: 1, // Default user for error cases
          jobTitle: 'Unknown',
          companyName: 'Unknown',
          jobUrl: request.jobUrl,
          result: 'failed',
          notes: `Error: ${(error as Error).message}`,
        });
      }

      return {
        success: false,
        message: `‚ùå Enhanced auto-apply failed: ${(error as Error).message}`,
      };
    } finally {
      // Keep browser open for potential submission
      // It will be closed after submission or timeout
    }
  }

  private async launchBrowser(): Promise<Browser> {
    if (!this.browser) {
      try {
        this.browser = await chromium.launch({
          headless: true,
          args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote', 
            '--single-process',
            '--disable-gpu',
            '--disable-web-security',
            '--disable-features=VizDisplayCompositor',
            '--disable-background-timer-throttling',
            '--disable-renderer-backgrounding',
            '--disable-backgrounding-occluded-windows',
            '--disable-ipc-flooding-protection',
            '--force-color-profile=srgb',
            '--disable-extensions',
            '--disable-default-apps',
            '--disable-sync',
            '--disable-translate',
            '--hide-scrollbars',
            '--metrics-recording-only',
            '--mute-audio',
            '--no-default-browser-check',
            '--disable-background-networking'
          ],
          chromiumSandbox: false
        });
      } catch (error) {
        console.error('Failed to launch browser:', error);
        if (error instanceof Error && (
          error.message.includes('Executable doesn\'t exist') ||
          error.message.includes('Host system is missing dependencies') ||
          error.message.includes('browserType.launch')
        )) {
          throw new Error('BROWSER_DEPENDENCIES_MISSING: Playwright browsers not installed. Please run: npx playwright install');
        }
        throw error;
      }
    }
    return this.browser;
  }

  private detectPlatform(jobUrl: string): string {
    const url = jobUrl.toLowerCase();
    if (url.includes('greenhouse')) return 'Greenhouse';
    if (url.includes('lever')) return 'Lever';
    if (url.includes('workday')) return 'Workday';
    if (url.includes('bamboohr')) return 'BambooHR';
    if (url.includes('smartrecruiters')) return 'SmartRecruiters';
    if (url.includes('jobvite')) return 'Jobvite';
    if (url.includes('taleo')) return 'Taleo';
    if (url.includes('successfactors')) return 'SuccessFactors';
    if (url.includes('icims')) return 'iCIMS';
    return 'Company Website';
  }

  private async extractJobDetails(page: Page, jobUrl: string): Promise<{
    jobTitle: string;
    companyName: string;
    jobDescription: string;
  }> {
    try {
      const pageContent = await page.content();
      const details = await this.openaiService.extractJobDetails(pageContent, jobUrl);
      return {
        jobTitle: details.jobTitle,
        companyName: details.companyName,
        jobDescription: details.jobDescription,
      };
    } catch (error) {
      console.log('Job details extraction failed, using manual detection');
      return await this.manualJobDetailsExtraction(page);
    }
  }

  private async manualJobDetailsExtraction(page: Page): Promise<{
    jobTitle: string;
    companyName: string;
    jobDescription: string;
  }> {
    const jobTitle = await page.locator('h1, [data-testid*="job-title"], .job-title, #job-title').first().textContent() || 'Unknown Position';
    const companyName = await page.locator('[data-testid*="company"], .company-name, #company-name').first().textContent() || 'Unknown Company';
    const jobDescription = await page.locator('[data-testid*="description"], .job-description, #job-description').first().textContent() || '';

    return { jobTitle, companyName, jobDescription };
  }

  private async findApplicationForm(page: Page): Promise<string | null> {
    const applySelectors = [
      'a:has-text("Apply")',
      'button:has-text("Apply")',
      'a:has-text("Apply Now")',
      'button:has-text("Apply Now")',
      '[data-testid*="apply"]',
      '[class*="apply"]',
      '#apply-button'
    ];

    for (const selector of applySelectors) {
      try {
        const element = await page.locator(selector).first();
        if (await element.isVisible({ timeout: 2000 })) {
          await element.click();
          await page.waitForTimeout(3000);
          return page.url();
        }
      } catch (e) {
        // Continue to next selector
      }
    }

    return null;
  }

  private async analyzeAndFillForm(
    page: Page,
    profile: ComprehensiveProfile,
    resumeFile?: Buffer,
    coverLetterFile?: Buffer,
    sessionId?: string
  ): Promise<Record<string, any>> {
    const filledData: Record<string, any> = {};

    try {
      // Fill basic info fields
      await this.fillBasicInfo(page, profile, filledData);
      
      // Fill address fields
      await this.fillAddressInfo(page, profile, filledData);
      
      // Fill work authorization
      await this.fillWorkAuthorization(page, profile, filledData);
      
      // Handle file uploads
      if (resumeFile) {
        await this.handleFileUpload(page, 'resume', resumeFile, sessionId);
        filledData.resumeUploaded = true;
      }
      
      if (coverLetterFile) {
        await this.handleFileUpload(page, 'cover-letter', coverLetterFile, sessionId);
        filledData.coverLetterUploaded = true;
      }

      // Fill custom responses
      if (profile.customResponses) {
        await this.fillCustomResponses(page, profile.customResponses, filledData);
      }

      console.log('‚úÖ Form filling completed');
      return filledData;

    } catch (error) {
      console.error('Form filling error:', error);
      throw error;
    }
  }

  private async fillBasicInfo(page: Page, profile: ComprehensiveProfile, filledData: Record<string, any>) {
    const fieldMappings = [
      { selectors: ['input[name*="firstName"]', 'input[id*="first"]', 'input[placeholder*="First" i]'], value: profile.name.split(' ')[0], key: 'firstName' },
      { selectors: ['input[name*="lastName"]', 'input[id*="last"]', 'input[placeholder*="Last" i]'], value: profile.name.split(' ').slice(1).join(' '), key: 'lastName' },
      { selectors: ['input[name*="name"]', 'input[id*="name"]', 'input[placeholder*="Full Name" i]'], value: profile.name, key: 'fullName' },
      { selectors: ['input[type="email"]', 'input[name*="email"]'], value: profile.email, key: 'email' },
      { selectors: ['input[type="tel"]', 'input[name*="phone"]', 'input[placeholder*="phone" i]'], value: profile.phone, key: 'phone' },
    ];

    for (const mapping of fieldMappings) {
      for (const selector of mapping.selectors) {
        try {
          const field = page.locator(selector).first();
          if (await field.isVisible({ timeout: 1000 })) {
            await field.fill(mapping.value);
            filledData[mapping.key] = mapping.value;
            console.log(`‚úÖ Filled ${mapping.key}: ${mapping.value}`);
            break;
          }
        } catch (e) {
          // Continue to next selector
        }
      }
    }
  }

  private async fillAddressInfo(page: Page, profile: ComprehensiveProfile, filledData: Record<string, any>) {
    const addressMappings = [
      { selectors: ['input[name*="address"]', 'input[id*="address"]'], value: profile.address, key: 'address' },
      { selectors: ['input[name*="city"]', 'input[id*="city"]'], value: profile.city, key: 'city' },
      { selectors: ['input[name*="state"]', 'input[id*="state"]'], value: profile.state, key: 'state' },
      { selectors: ['input[name*="zip"]', 'input[name*="postal"]', 'input[id*="zip"]'], value: profile.zipCode, key: 'zipCode' },
    ];

    for (const mapping of addressMappings) {
      if (!mapping.value) continue;
      
      for (const selector of mapping.selectors) {
        try {
          const field = page.locator(selector).first();
          if (await field.isVisible({ timeout: 1000 })) {
            await field.fill(mapping.value);
            filledData[mapping.key] = mapping.value;
            break;
          }
        } catch (e) {
          // Continue
        }
      }
    }
  }

  private async fillWorkAuthorization(page: Page, profile: ComprehensiveProfile, filledData: Record<string, any>) {
    if (!profile.workAuthorization) return;

    const workAuthSelectors = [
      'select[name*="authorization"]',
      'select[name*="work"]',
      'select[id*="work"]'
    ];

    for (const selector of workAuthSelectors) {
      try {
        const select = page.locator(selector).first();
        if (await select.isVisible({ timeout: 1000 })) {
          await select.selectOption({ label: profile.workAuthorization });
          filledData.workAuthorization = profile.workAuthorization;
          break;
        }
      } catch (e) {
        // Continue
      }
    }
  }

  private async handleFileUpload(page: Page, fileType: 'resume' | 'cover-letter', fileBuffer: Buffer, sessionId?: string) {
    const uploadSelectors = [
      `input[type="file"][name*="${fileType}"]`,
      `input[type="file"][id*="${fileType}"]`,
      'input[type="file"]'
    ];

    // Save file temporarily
    const tempDir = path.join(process.cwd(), 'temp');
    await fs.mkdir(tempDir, { recursive: true });
    const tempFilePath = path.join(tempDir, `${fileType}_${sessionId || Date.now()}.pdf`);
    await fs.writeFile(tempFilePath, fileBuffer);

    for (const selector of uploadSelectors) {
      try {
        const fileInput = page.locator(selector).first();
        if (await fileInput.isVisible({ timeout: 2000 })) {
          await fileInput.setInputFiles(tempFilePath);
          console.log(`‚úÖ Uploaded ${fileType}`);
          
          // Cleanup temp file
          setTimeout(() => fs.unlink(tempFilePath).catch(console.error), 5000);
          return;
        }
      } catch (e) {
        // Continue
      }
    }

    // Cleanup temp file if upload failed
    await fs.unlink(tempFilePath).catch(console.error);
  }

  private async fillCustomResponses(page: Page, responses: Record<string, string>, filledData: Record<string, any>) {
    for (const [question, answer] of Object.entries(responses)) {
      const textareas = await page.locator('textarea').all();
      for (const textarea of textareas) {
        try {
          const label = await textarea.locator('..').locator('label').first().textContent();
          if (label && label.toLowerCase().includes(question.toLowerCase())) {
            await textarea.fill(answer);
            filledData[`custom_${question}`] = answer;
            break;
          }
        } catch (e) {
          // Continue
        }
      }
    }
  }

  private async startAutoSubmitTimer(sessionId: string, page: Page) {
    // Set 60-second timer for auto-submit
    setTimeout(async () => {
      try {
        const session = await storage.getApplicationSessionById(sessionId);
        if (!session || session.status !== 'pending_review') {
          return; // Already processed
        }

        console.log(`‚è∞ Auto-submitting application for session ${sessionId}`);
        await this.submitApplication(sessionId, page, 'auto');
      } catch (error) {
        console.error('Auto-submit error:', error);
      }
    }, 60000); // 60 seconds
  }

  async submitApplication(sessionId: string, page: Page, method: 'auto' | 'manual'): Promise<void> {
    try {
      // Find and click submit button
      const submitSelectors = [
        'button[type="submit"]',
        'input[type="submit"]',
        'button:has-text("Submit")',
        'button:has-text("Apply")',
        'button:has-text("Send Application")',
        '[data-testid*="submit"]'
      ];

      let submitted = false;
      for (const selector of submitSelectors) {
        try {
          const submitButton = page.locator(selector).first();
          if (await submitButton.isVisible({ timeout: 2000 })) {
            await submitButton.click();
            submitted = true;
            console.log(`‚úÖ Application submitted via ${method}`);
            break;
          }
        } catch (e) {
          // Continue
        }
      }

      // Wait for submission to complete
      await page.waitForTimeout(3000);

      // Take screenshot and HTML snapshot
      const screenshotPath = await this.screenshotService.captureSubmissionScreenshot(page, sessionId);
      const htmlSnapshotPath = await this.screenshotService.saveHtmlSnapshot(page, sessionId);

      // Update session
      await storage.updateApplicationSession(sessionId, {
        status: 'submitted',
        submissionResult: submitted ? 'success' : 'failed',
        submittedAt: new Date(),
        screenshotPath,
        htmlSnapshotPath,
      });

      // Send confirmation notifications
      const session = await storage.getApplicationSessionById(sessionId);
      if (session) {
        await this.sendConfirmationNotifications(session, method, submitted);
      }

      // Log the result
      await storage.createApplicationLog({
        sessionId,
        userId: session?.userId || 1,
        jobTitle: session?.jobTitle || 'Unknown',
        companyName: session?.company || 'Unknown',
        jobUrl: session?.jobUrl || '',
        result: submitted ? 'success' : 'failed',
        notes: `Submitted via ${method}`,
      });

    } catch (error) {
      console.error('Application submission error:', error);
      
      await storage.updateApplicationSession(sessionId, {
        status: 'failed',
        submissionResult: 'failed',
        errorMessage: (error as Error).message,
      });
    } finally {
      // Close browser
      if (this.browser) {
        await this.browser.close();
        this.browser = null;
      }
    }
  }

  private async sendConfirmationNotifications(
    session: ApplicationSessionRecord,
    method: 'auto' | 'manual',
    success: boolean
  ) {
    const profile = session.profileData as ComprehensiveProfile;
    
    // Send email confirmation
    await this.emailService.sendConfirmationEmail(session, success);

    // Send WhatsApp confirmation if enabled
    if (profile.enableWhatsappNotifications && profile.whatsappNumber) {
      await this.whatsappService.sendJobApplicationConfirmation(
        profile.whatsappNumber,
        session.jobTitle || 'Unknown Position',
        session.company || 'Unknown Company',
        success ? 'success' : 'failed',
        method,
        session.errorMessage || undefined
      );
    }
  }

  private encryptCredentials(credentials: LoginCredentials): string {
    const algorithm = 'aes-256-cbc';
    const key = crypto.scryptSync(process.env.ENCRYPTION_KEY || 'default-key', 'salt', 32);
    const iv = crypto.randomBytes(16);
    
    const cipher = crypto.createCipheriv(algorithm, key, iv);
    let encrypted = cipher.update(JSON.stringify(credentials), 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    return iv.toString('hex') + ':' + encrypted;
  }

  private decryptCredentials(encryptedData: string): LoginCredentials {
    const algorithm = 'aes-256-cbc';
    const key = crypto.scryptSync(process.env.ENCRYPTION_KEY || 'default-key', 'salt', 32);
    
    const [ivHex, encrypted] = encryptedData.split(':');
    const iv = Buffer.from(ivHex, 'hex');
    
    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return JSON.parse(decrypted);
  }
}